#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <stdio.h>
//Adrian Faircloth
//3-22-22
//CSC460
//Beasty Print Daemon: Daemon

//Sets up shared resources for print buffer, prints quotes from files generated by users, cleans resources when signalled to stop

//Defines for sems
#define MUTEX 0
#define FULL 1
#define EMPTY 2

//Defines for shmem trackers and stop var
#define FRONT shmem[size].id
#define REAR shmem[size + 1].id
#define STOP shmem[size + 2].id

//Struct for shared memory
struct usrData {
	int id;
	char filename[15];
};

main(int argc, char*argv[])
{
	int shmid; 
	struct usrData *shmem;
	int sem_id;
	FILE *fp;

//Checking if shmemdata exists, if so Daemon is currently running
	if ((fp = fopen("shmemdata", "r")) != NULL)
	{
		printf("Daemon already active.\n");
		return(0);
	}

//Checking for buffer size passed in on command line
	if (argc == 1)
	{
		printf("No buffer size given on command line.\n");
		return(0);
	}
	
//Getting buffer size and checking if it is in range (1 - 10)
	int size = atoi(argv[1]);
	if (size < 1 || size > 10)
	{
		printf("Buffer size out of range (1 - 10).\n");
		return(0);
	}

//Getting 3 semaphores: MUTEX, FULL, and EMPTY	
	sem_id = semget(IPC_PRIVATE, 3, 0777);

	if (sem_id == -1)
	{
		printf("Failed to get semaphores.\n");
		return(0);
	}

//Setting initial values for each semaphore
	semctl(sem_id, MUTEX, SETVAL, 1);
	semctl(sem_id, FULL, SETVAL, 0);
	semctl(sem_id, EMPTY, SETVAL, size);
	
//Getting shared memory of structs
//Contains 3 extra structs for tracking front and rear of buffer and the STOP var
	shmid = shmget(IPC_PRIVATE, (size+3) * sizeof(struct usrData), 0777);
	if (shmid == -1)
	{
		printf("Failed to get shared memory.\n");
		return(0);
	}
	shmem = (struct usrData*) shmat(shmid, NULL, SHM_RND);

//Setting initial values for non-buffer structs in shared memory
	FRONT = 0;
	REAR = 0;
	STOP = 0;

//Creating shmemdata and writing IDs and buffer size
	if ((fp = fopen("shmemdata", "w+")) == NULL)
	{
		printf("Failed to open shmemdata.\n");
		return(0);
	}
	fprintf(fp, "%d %d %d", sem_id, shmid, size);
	fclose(fp);	

	char c;

//Infinite loop for getting print requests and printing quotes stored in user files
	while (1)
	{
	//Syncing buffer w/ users through semaphores
		p(FULL, sem_id);

	//Breaking infinite loop if STOP signal is switched
		if (STOP != 0) break;
		p(MUTEX, sem_id);

	//Critical Section
	//Printing message indicating process that called this print job
		printf("Print job for %d:\n\t", shmem[FRONT].id);
		
	//Opening user file using filename stored in shared memory
		if ((fp = fopen(shmem[FRONT].filename, "r")) == NULL)
		{
			printf("Error opening user file.\n");
			break;
		}

	//Printing quote from file
		while ( (c = fgetc(fp)) != EOF)
			printf("%c", c);
		fclose(fp);
		printf("\n");

	//Incrementing tracker for front of buffer
		FRONT = (FRONT + 1) % size;

		v(MUTEX, sem_id);
		v(EMPTY, sem_id);
	}

//Removing all shared resources after breaking infinite loop
//
//Deleting shmemdata file	
	remove("shmemdata");

//Detatching and removing shared memory array
	if (shmdt(shmem) == -1) printf("Error detatching from shared memory.\n");
	if ((shmctl(shmid, IPC_RMID, NULL)) == -1)
		printf("Error removing shared memory.\n");

//Removing semaphores
	if ((semctl(sem_id, 0, IPC_RMID, 0)) == -1)
		printf("Error removing semaphores.\n");
	return(0);
}

p(int s,int sem_id)
{
struct sembuf sops;

sops.sem_num = s;
sops.sem_op = -1;
sops.sem_flg = 0;
if((semop(sem_id, &sops, 1)) == -1) printf("%s", "'P' error\n");
}

v(int s, int sem_id)
{
struct sembuf sops;

sops.sem_num = s;
sops.sem_op = 1;
sops.sem_flg = 0;
if((semop(sem_id, &sops, 1)) == -1) printf("%s","'V' error\n");
}


         
